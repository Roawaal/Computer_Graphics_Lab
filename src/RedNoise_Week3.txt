#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/sdw/CanvasTriangle.h>
#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/sdw/DrawingWindow.h>
#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/sdw/Utils.h>
#include <fstream>
#include <vector>
#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/glm-0.9.7.2/glm/glm.hpp>
#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/sdw/Colour.h>
#include </home/kz21093/Downloads/RedNoise/RedNoise/libs/sdw/CanvasPoint.h>


#define WIDTH 320
#define HEIGHT 240


// Utility functions
CanvasPoint randomPoint() {
    return CanvasPoint(rand() % WIDTH, rand() % HEIGHT);
}

Colour randomColour() {
    return Colour(rand() % 256, rand() % 256, rand() % 256);
}


void draw(DrawingWindow &window) {
    window.clearPixels();
    for (size_t y = 0; y < window.height; y++) {
        for (size_t x = 0; x < window.width; x++) {
            uint32_t colour = (255 << 24); // Setting to black background
            window.setPixelColour(x, y, colour);
        }
    }
}
std::vector<float> interpolate(float from, float to, int numberOfValues) {
    std::vector<float> values;
    for (int i = 0; i < numberOfValues; i++) {
        float value = from + (i * ((to - from) / float(numberOfValues - 1)));
        values.push_back(value);
    }
    return values;
}

void drawLine(DrawingWindow &window, const CanvasPoint &from, const CanvasPoint &to, const Colour &colour) {
    float length = std::sqrt((to.x - from.x) * (to.x - from.x) + (to.y - from.y) * (to.y - from.y));
    std::vector<float> xValues = interpolate(from.x, to.x, length);
    std::vector<float> yValues = interpolate(from.y, to.y, length);

    for (int i = 0; i < length; i++) {
        uint32_t color = (255 << 24) + (colour.red << 16) + (colour.green << 8) + colour.blue;
        window.setPixelColour(xValues[i], yValues[i], color);
    }
}


void drawTriangle(CanvasTriangle triangle, Colour colour, DrawingWindow &window) {
    drawLine(triangle[0], triangle[1], colour, window);  // Draw line between first and second vertices
    drawLine(triangle[1], triangle[2], colour, window);  // Draw line between second and third vertices
    drawLine(triangle[2], triangle[0], colour, window);  // Draw line between third and first vertices
}


void drawFilledTriangle(const CanvasTriangle& triangle, const Colour& colour, DrawingWindow& window) {
    CanvasPoint v0 = triangle[0];
    CanvasPoint v1 = triangle[1];
    CanvasPoint v2 = triangle[2];
    
    // Sort the vertices by y-value
    if (v1.y < v0.y) std::swap(v1, v0);
    if (v2.y < v0.y) std::swap(v2, v0);
    if (v2.y < v1.y) std::swap(v2, v1);

    // Compute the slopes
    float slope0 = (v1.x - v0.x) / (v1.y - v0.y);
    float slope1 = (v2.x - v0.x) / (v2.y - v0.y);

    for (int y = v0.y; y <= v1.y; y++) {
        int xa = v0.x + slope0 * (y - v0.y);
        int xb = v0.x + slope1 * (y - v0.y);
        if (xa > xb) std::swap(xa, xb);

        for (int x = xa; x <= xb; x++) {
            window.setPixelColour(x, y, colour.getPacked());
        }
    }

    float slope2 = (v2.x - v1.x) / (v2.y - v1.y);

    for (int y = v1.y; y <= v2.y; y++) {
        int xa = v1.x + slope2 * (y - v1.y);
        int xb = v0.x + slope1 * (y - v0.y);
        if (xa > xb) std::swap(xa, xb);

        for (int x = xa; x <= xb; x++) {
            window.setPixelColour(x, y, colour.getPacked());
        }
    }

    // Drawing the triangle outline in white
    drawLine(v0, v1, Colour(255, 255, 255), window);
    drawLine(v1, v2, Colour(255, 255, 255), window);
    drawLine(v2, v0, Colour(255, 255, 255), window);
}




void handleEvent(SDL_Event event, DrawingWindow &window) {
    if (event.type == SDL_KEYDOWN) {
        if (event.key.keysym.sym == SDLK_LEFT) std::cout << "LEFT" << std::endl;
        else if (event.key.keysym.sym == SDLK_RIGHT) std::cout << "RIGHT" << std::endl;
        else if (event.key.keysym.sym == SDLK_UP) std::cout << "UP" << std::endl;
        else if (event.key.keysym.sym == SDLK_DOWN) std::cout << "DOWN" << std::endl;
        else if (event.key.keysym.sym == SDLK_u) {
            CanvasPoint randomPoint1(rand() % WIDTH, rand() % HEIGHT);
            CanvasPoint randomPoint2(rand() % WIDTH, rand() % HEIGHT);
            CanvasPoint randomPoint3(rand() % WIDTH, rand() % HEIGHT);
            CanvasTriangle randomTriangle(randomPoint1, randomPoint2, randomPoint3);
            Colour colour(rand() % 256, rand() % 256, rand() % 256);
            drawTriangle(randomTriangle, colour, window);
        }
    } else if (event.type == SDL_MOUSEBUTTONDOWN) {
        window.savePPM("output.ppm");
        window.saveBMP("output.bmp");
    }

}


int main(int argc, char *argv[]) {
    DrawingWindow window = DrawingWindow(WIDTH, HEIGHT, false);

    window.clearPixels();
/*
    Colour red(255, 0, 0);
    Colour green(0, 255, 0);
    Colour blue(0, 0, 255);
    Colour yellow(255, 255, 0);

    drawLine(window, CanvasPoint(0, 0), CanvasPoint(window.width / 2 - 1, window.height / 2 - 1), red);
    drawLine(window, CanvasPoint(window.width - 1, 0), CanvasPoint(window.width / 2 - 1, window.height / 2 - 1), green);
    drawLine(window, CanvasPoint(window.width / 2 - 1, 0), CanvasPoint(window.width / 2 - 1, window.height - 1), blue);
    drawLine(window, CanvasPoint((window.width - window.width / 3) / 2 - 1, window.height / 2 - 1), CanvasPoint((window.width + window.width / 3) / 2 - 1, window.height / 2 - 1), yellow);
*/
	SDL_Event event;
    // Initialize the window with the red background once
    draw(window);
    window.renderFrame();

    while (true) {
        // We MUST poll for events - otherwise the window will freeze !
        if (window.pollForInputEvents(event)) handleEvent(event, window);
        
        // Randomly draw triangles when 'u' key is pressed
        if(event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_u) {
            for(int i = 0; i < 1; i++) {
                CanvasPoint v0(rand() % WIDTH, rand() % HEIGHT);
                CanvasPoint v1(rand() % WIDTH, rand() % HEIGHT);
                CanvasPoint v2(rand() % WIDTH, rand() % HEIGHT);
                CanvasTriangle triangle(v0, v1, v2);
                Colour randomColour(rand() % 256, rand() % 256, rand() % 256);
                drawTriangle(triangle, randomColour, window);
            }
            window.renderFrame();
        }
    }
}